#!/usr/bin/env bash

# Only display up to four directory components in the prompt.
PROMPT_DIRTRIM=4

# solarized colors
BASE03="\[$(tput setaf 8)\]"
BASE02="\[$(tput setaf 0)\]"
BASE01="\[$(tput setaf 10)\]"
BASE00="\[$(tput setaf 11)\]"
BASE0="\[$(tput setaf 12)\]"
BASE1="\[$(tput setaf 14)\]"
BASE2="\[$(tput setaf 7)\]"
BASE3="\[$(tput setaf 15)\]"
YELLOW="\[$(tput setaf 3)\]"
ORANGE="\[$(tput setaf 9)\]"
RED="\[$(tput setaf 1)\]"
MAGENTA="\[$(tput setaf 5)\]"
VIOLET="\[$(tput setaf 13)\]"
BLUE="\[$(tput setaf 4)\]"
CYAN="\[$(tput setaf 6)\]"
GREEN="\[$(tput setaf 2)\]"
RESET="\[$(tput sgr0)\]"


### Overwrite TrueColor Gruvbox Colors
# 38 sets foreground, 48 sets background
# More explanation: https://stackoverflow.com/a/26665998
# Since I use iTerm, I used the iterm2 specific RGB codes from this table:
# https://github.com/morhetz/gruvbox-contrib/blob/master/color.table
# general pattern:
#  \[    =escape non-printing characters so readline can keep track of number of characters
#  \e[   =escape sequence for color
#  38;   =route foreground
#  2;    =flag for 24bit color with 3 following components
#  R;G;B =RGB value for color
#  m     =end color escape sequence
# \]     =end outer escape sequence
BASE03="\[\e[38;2;146;131;116m\]" # 146-131-116
BASE02="\[\e[38;2;40;40;40m\]" # 40- 40- 40
BASE01="\[\e[38;2;170;176;30m\]" # 170-176- 30
BASE00="\[$(tput setaf 11)\]" # 250-189- 47
BASE0="\[\e[38;2;113;149;134m\]" # 113-149-134
BASE1="\[$(tput setaf 14)\]" # 142-192-124
BASE2="\[$(tput setaf 7)\]" #  168-153-132
BASE3="\[$(tput setaf 15)\]" # 235-219-178
YELLOW="\[$(tput setaf 3)\]" #  215-153- 33
ORANGE="\[\e[38;2;247;48;40m\]" #  247- 48- 40
RED="\[\e[38;2;190;15;23m\]" # 190- 15- 23
MAGENTA="\[$(tput setaf 5)\]" #  177- 98-134
VIOLET="\[$(tput setaf 13)\]" # 211-134-155
BLUE="\[$(tput setaf 4)\]" # 69-133-136
CYAN="\[$(tput setaf 6)\]" #  104-157-106
GREEN="\[\e[38;2;134;135;21m\]" # 134-135- 21
RESET="\[\e[0m\]" # just a 0 value resets


function git_prompt() {
  branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
  if [[ $? == 0 ]]; then
    printf "(%.10s%s) " "$branch" "$([[ -n $(git status -s) ]] && echo " ✗")"
  fi
}

function status_symbol() {
  if [[ $1 != 0 ]]; then
    echo -n "⚡ $1 ⚡ "
  fi
}

function right_prompt() {
  local str="$(date +'%H:%M:%S')"

  if [[ "$SSH_TTY" ]]; then
    str="$(id -u -n)@$(hostname -s) $str"
  fi

  tput sc
  printf "%*s" $COLUMNS "$str"
  tput rc
}

function ppwd() {
  [[ $COLUMNS -lt 60 ]] && return

  local path="$PWD"
  local path_depth=$(grep -o "/" <<< "$path" | wc -l)
  local cols=$((($COLUMNS * 2 / 5) - 10))

  for (( i=1; i<=$path_depth; i++))
  do
    if [[ ${#path} -gt $cols ]]; then
      path="$(echo "$path" | sed -e "s;\(/.\)[^/][^/]*;\1;")"
    fi
  done

  if [[ ${#path} -gt $cols ]]; then
    path="«${path:0-$cols}"
  fi

  echo "$path "
}

function root_check() {
  if [[ "$(id -u)" == 0 ]]; then
    echo "[ROOT] "
  fi
}

PS1="$BASE0\$(LS=\$?; right_prompt; exit \$LS)"
PS1+="$RED\$(status_symbol \$?)$RESET\n"
PS1+="\u@\h:$BASE1\$(ppwd)$GREEN\$(git_prompt)"
PS1+="$ORANGE\$(root_check)"
PS1+="$BASE01\\$ $RESET"

export PS1
